["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$zprint.range","~:imports",null,"~:requires",["^ ","~$s","~$clojure.string","^9","^9","~$edamame.core","^:"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$parse-string-all","^:"],"~:defs",["^ ","~$reassemble-range",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/sansarip/Dev/nw-calculator/resources/public/js/compiled/dev/zprint/range.cljc","~:line",296,"~:column",7,"~:end-line",296,"~:end-column",23,"~:arglists",["~#list",["~$quote",["^H",[["~$before-lines","~$range","~$after-lines"]]]]],"~:doc","Given before-lines, range, and after-lines where before-lines\n  and after-lines are sequences of lines, and range is a string\n  which has been formatted, reassemble these three chunks into a\n  single string with appropriate newlines joining them together.\n  Note that this is *not* an inverse to split-out-range, because\n  in that routine range is a seq of lines, and in this routine\n  range is a string.  Note also that we only join them with a \n  newline if there are two pieces, otherwise we get extra lines."],"^5","~$zprint.range/reassemble-range","^B","resources/public/js/compiled/dev/zprint/range.cljc","^F",23,"~:method-params",["^H",[["^J","^K","^L"]]],"~:protocol-impl",null,"~:arglists-meta",["^H",[null,null]],"^D",1,"~:variadic?",false,"^C",296,"~:ret-tag","~$string","^E",296,"~:max-fixed-arity",3,"~:fn-var",true,"^G",["^H",["^I",["^H",[["^J","^K","^L"]]]]],"^M","Given before-lines, range, and after-lines where before-lines\n  and after-lines are sequences of lines, and range is a string\n  which has been formatted, reassemble these three chunks into a\n  single string with appropriate newlines joining them together.\n  Note that this is *not* an inverse to split-out-range, because\n  in that routine range is a seq of lines, and in this routine\n  range is a string.  Note also that we only join them with a \n  newline if there are two pieces, otherwise we get extra lines."],"~$expand-range-to-top-level",["^ ","^@",null,"^A",["^ ","^B","/Users/sansarip/Dev/nw-calculator/resources/public/js/compiled/dev/zprint/range.cljc","^C",164,"^D",7,"^E",164,"^F",32,"^G",["^H",["^I",["^H",[["~$filestring","~$lines","~$start","~$end","~$dbg?"]]]]],"^M","Given a string which contains lines and a vector of those lines,\n  and a range of lines inside of them, expand the range such that\n  it covers everything from the first non-blank line beyond the\n  previous top level expression before the start to the end of the\n  top level expression containing the end of the range.  Returns\n  [actual-start actual-end].  Note that start, end, actual-start\n  and actual-end are all zero based line numbers."],"^5","~$zprint.range/expand-range-to-top-level","^B","resources/public/js/compiled/dev/zprint/range.cljc","^F",32,"^O",["^H",[["^X","^Y","^Z","^[","^10"]]],"^P",null,"^Q",["^H",[null,null]],"^D",1,"^R",false,"^C",164,"^S","~$cljs.core/IVector","^E",164,"^U",5,"^V",true,"^G",["^H",["^I",["^H",[["^X","^Y","^Z","^[","^10"]]]]],"^M","Given a string which contains lines and a vector of those lines,\n  and a range of lines inside of them, expand the range such that\n  it covers everything from the first non-blank line beyond the\n  previous top level expression before the start to the end of the\n  top level expression containing the end of the range.  Returns\n  [actual-start actual-end].  Note that start, end, actual-start\n  and actual-end are all zero based line numbers."],"~$find-row",["^ ","^@",null,"^A",["^ ","^B","/Users/sansarip/Dev/nw-calculator/resources/public/js/compiled/dev/zprint/range.cljc","^C",83,"^D",7,"^E",83,"^F",15,"^G",["^H",["^I",["^H",[["~$row-vec","~$linenumber","^10","~$scan-size"],["^14","~$n","^10"]]]]],"^M","Given a vector of rows, find the row that contains a line number,\n  linenumber, and return the number of that row in the vector.\n  row-vec looks like this: \n  [{:row 2, :col 1, :end-row 7, :end-col 21}\n   {:row 9, :col 1, :end-row 18, :end-col 6} \n   {:row 20, :col 1, :end-row 29, :end-col 6}]\n  If none exists, return the next row. Note that line numbers are 1\n  based, not zero based for this routine and the information in\n  row-vec, but the index into row-vec that this routine returns is\n  zero based.  Uses a binary search. If the line number is before the\n  first information in the row-vec, returns :before-beginning, and\n  if it is after the last information in the row-vec, returns\n  :beyond-end. Note that the row-vec as returned from edamame\n  parse-string-all contains not only maps like {:row 5 :end-row 10}\n  but also nils for things that didn't have paired delimiters around\n  them (e.g., keywords, strings, etc.).  You must remove those\n  from row-vec before calling find-row.  Note that find-row returns an \n  index into row-vec, and it must be the row-vec that has had nils \n  removed from it (or this routine would do that for you).","~:top-fn",["^ ","^R",false,"~:fixed-arity",4,"^U",4,"^O",[["^14","^15","^10","^16"],["^14","~$n","^10"]],"^G",["^H",[["^14","^15","^10","^16"],["^14","~$n","^10"]]],"^Q",["^H",[null,null]]]],"^5","~$zprint.range/find-row","^B","resources/public/js/compiled/dev/zprint/range.cljc","^F",15,"^17",["^ ","^R",false,"^18",4,"^U",4,"^O",[["^14","^15","^10","^16"],["^14","~$n","^10"]],"^G",["^H",[["^14","^15","^10","^16"],["^14","~$n","^10"]]],"^Q",["^H",[null,null]]],"^O",[["^14","^15","^10","^16"],["^14","~$n","^10"]],"^P",null,"^18",4,"^Q",["^H",[null,null]],"^D",1,"^R",false,"~:methods",[["^ ","^18",4,"^R",false,"~:tag",["^4",["~$any","~$cljs.core/Keyword","~$number"]]],["^ ","^18",3,"^R",false,"^1;",["^4",["^1<","^1=","^1>"]]]],"^C",83,"^E",83,"^U",4,"^V",true,"^G",["^H",[["^14","^15","^10","^16"],["^14","~$n","^10"]]],"^M","Given a vector of rows, find the row that contains a line number,\n  linenumber, and return the number of that row in the vector.\n  row-vec looks like this: \n  [{:row 2, :col 1, :end-row 7, :end-col 21}\n   {:row 9, :col 1, :end-row 18, :end-col 6} \n   {:row 20, :col 1, :end-row 29, :end-col 6}]\n  If none exists, return the next row. Note that line numbers are 1\n  based, not zero based for this routine and the information in\n  row-vec, but the index into row-vec that this routine returns is\n  zero based.  Uses a binary search. If the line number is before the\n  first information in the row-vec, returns :before-beginning, and\n  if it is after the last information in the row-vec, returns\n  :beyond-end. Note that the row-vec as returned from edamame\n  parse-string-all contains not only maps like {:row 5 :end-row 10}\n  but also nils for things that didn't have paired delimiters around\n  them (e.g., keywords, strings, etc.).  You must remove those\n  from row-vec before calling find-row.  Note that find-row returns an \n  index into row-vec, and it must be the row-vec that has had nils \n  removed from it (or this routine would do that for you)."],"~$scan-for-row",["^ ","^@",null,"^A",["^ ","^B","/Users/sansarip/Dev/nw-calculator/resources/public/js/compiled/dev/zprint/range.cljc","^C",36,"^D",7,"^E",36,"^F",19,"^G",["^H",["^I",["^H",[["^14","~$row-vec-index","^15","~$max-tries"]]]]],"^M","Given a row-vec, and a current index into the row-vec, if the\n  linenumber is within that row, return the index to that row.   If\n  the linenumber is not in that row, then scan either way for\n  max-tries looking for a match for this linenumber.  Return the\n  row index if a row is found containing this linenumber. If it is\n  between two rows, return the row after.  If we fall off the either\n  end of the row-vec, then return :before-beginning or :beyone-end.  \n  If we don't find anything after trying for max-tries, :before or\n  :after, depending on which way we should try next."],"^5","~$zprint.range/scan-for-row","^B","resources/public/js/compiled/dev/zprint/range.cljc","^F",19,"^O",["^H",[["^14","^1@","^15","^1A"]]],"^P",null,"^Q",["^H",[null,null]],"^D",1,"^R",false,"^C",36,"^S",["^4",["^1<","^1=","^1>"]],"^E",36,"^U",4,"^V",true,"^G",["^H",["^I",["^H",[["^14","^1@","^15","^1A"]]]]],"^M","Given a row-vec, and a current index into the row-vec, if the\n  linenumber is within that row, return the index to that row.   If\n  the linenumber is not in that row, then scan either way for\n  max-tries looking for a match for this linenumber.  Return the\n  row index if a row is found containing this linenumber. If it is\n  between two rows, return the row after.  If we fall off the either\n  end of the row-vec, then return :before-beginning or :beyone-end.  \n  If we don't find anything after trying for max-tries, :before or\n  :after, depending on which way we should try next."],"~$row-before?",["^ ","^@",null,"^A",["^ ","^B","/Users/sansarip/Dev/nw-calculator/resources/public/js/compiled/dev/zprint/range.cljc","^C",18,"^D",7,"^E",18,"^F",18,"^G",["^H",["^I",["^H",[["~$row-a","~$row-b"]]]]],"^M","Given two rows, is the first before the second?"],"^5","~$zprint.range/row-before?","^B","resources/public/js/compiled/dev/zprint/range.cljc","^F",18,"^O",["^H",[["^1D","^1E"]]],"^P",null,"^Q",["^H",[null,null]],"^D",1,"^R",false,"^C",18,"^S","~$boolean","^E",18,"^U",2,"^V",true,"^G",["^H",["^I",["^H",[["^1D","^1E"]]]]],"^M","Given two rows, is the first before the second?"],"~$split-out-range",["^ ","^@",null,"^A",["^ ","^B","/Users/sansarip/Dev/nw-calculator/resources/public/js/compiled/dev/zprint/range.cljc","^C",281,"^D",7,"^E",281,"^F",22,"^G",["^H",["^I",["^H",[["^Y","^Z","^["]]]]],"^M","Given lines, a sequence of lines, and a start and end of a range,\n  split the sequence of lines into three parts: [before-lines range\n  after-lines].  If any of these collections would be empty, return\n  an empty sequence. End must be equal to or greater than start. If\n  end is neg?, there will be no range."],"^5","~$zprint.range/split-out-range","^B","resources/public/js/compiled/dev/zprint/range.cljc","^F",22,"^O",["^H",[["^Y","^Z","^["]]],"^P",null,"^Q",["^H",[null,null]],"^D",1,"^R",false,"^C",281,"^S","^12","^E",281,"^U",3,"^V",true,"^G",["^H",["^I",["^H",[["^Y","^Z","^["]]]]],"^M","Given lines, a sequence of lines, and a start and end of a range,\n  split the sequence of lines into three parts: [before-lines range\n  after-lines].  If any of these collections would be empty, return\n  an empty sequence. End must be equal to or greater than start. If\n  end is neg?, there will be no range."],"~$next-non-blank-line",["^ ","^@",null,"^A",["^ ","^B","/Users/sansarip/Dev/nw-calculator/resources/public/js/compiled/dev/zprint/range.cljc","^C",137,"^D",7,"^E",137,"^F",26,"^G",["^H",["^I",["^H",[["~$line-vec","~$index"]]]]],"^M","Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first non-blank line including or after that\n  starting line index."],"^5","~$zprint.range/next-non-blank-line","^B","resources/public/js/compiled/dev/zprint/range.cljc","^F",26,"^O",["^H",[["^1K","^1L"]]],"^P",null,"^Q",["^H",[null,null]],"^D",1,"^R",false,"^C",137,"^E",137,"^U",2,"^V",true,"^G",["^H",["^I",["^H",[["^1K","^1L"]]]]],"^M","Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first non-blank line including or after that\n  starting line index."],"~$between-rows?",["^ ","^@",null,"^A",["^ ","^B","/Users/sansarip/Dev/nw-calculator/resources/public/js/compiled/dev/zprint/range.cljc","^C",24,"^D",7,"^E",24,"^F",20,"^G",["^H",["^I",["^H",[["^15","^1D","^1E"]]]]],"^M","Given two rows, if the linenumber is between the rows, return true, else\n  nil."],"^5","~$zprint.range/between-rows?","^B","resources/public/js/compiled/dev/zprint/range.cljc","^F",20,"^O",["^H",[["^15","^1D","^1E"]]],"^P",null,"^Q",["^H",[null,null]],"^D",1,"^R",false,"^C",24,"^S",["^4",["^1G","~$clj-nil"]],"^E",24,"^U",3,"^V",true,"^G",["^H",["^I",["^H",[["^15","^1D","^1E"]]]]],"^M","Given two rows, if the linenumber is between the rows, return true, else\n  nil."],"~$abs",["^ ","^@",null,"^A",["^ ","^B","/Users/sansarip/Dev/nw-calculator/resources/public/js/compiled/dev/zprint/range.cljc","^C",81,"^D",7,"^E",81,"^F",10,"^G",["^H",["^I",["^H",[["~$n"]]]]],"^M","Return the absolute value of a number."],"^5","~$zprint.range/abs","^B","resources/public/js/compiled/dev/zprint/range.cljc","^F",10,"^O",["^H",[["~$n"]]],"^P",null,"^Q",["^H",[null,null]],"^D",1,"^R",false,"^C",81,"^S",["^4",[null,"^1>"]],"^E",81,"^U",1,"^V",true,"^G",["^H",["^I",["^H",[["~$n"]]]]],"^M","Return the absolute value of a number."],"~$in-row?",["^ ","^@",null,"^A",["^ ","^B","/Users/sansarip/Dev/nw-calculator/resources/public/js/compiled/dev/zprint/range.cljc","^C",9,"^D",7,"^E",9,"^F",14,"^G",["^H",["^I",["^H",[["~$n","~$row"]]]]],"^M","If a line number n is in a particular edamame row, return the row map.\n  If it is not in the row, return +1 or -1 to indicate which direction\n  to look."],"^5","~$zprint.range/in-row?","^B","resources/public/js/compiled/dev/zprint/range.cljc","^F",14,"^O",["^H",[["~$n","^1T"]]],"^P",null,"^Q",["^H",[null,null]],"^D",1,"^R",false,"^C",9,"^S",["^4",[null,"^1>","^1P"]],"^E",9,"^U",2,"^V",true,"^G",["^H",["^I",["^H",[["~$n","^1T"]]]]],"^M","If a line number n is in a particular edamame row, return the row map.\n  If it is not in the row, return +1 or -1 to indicate which direction\n  to look."],"~$previous-non-blank-line",["^ ","^@",null,"^A",["^ ","^B","/Users/sansarip/Dev/nw-calculator/resources/public/js/compiled/dev/zprint/range.cljc","^C",150,"^D",7,"^E",150,"^F",30,"^G",["^H",["^I",["^H",[["^1K","^1L"]]]]],"^M","Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first previous non-blank line including or before\n  that starting line index.  Returns -1 if no non-blank line found."],"^5","~$zprint.range/previous-non-blank-line","^B","resources/public/js/compiled/dev/zprint/range.cljc","^F",30,"^O",["^H",[["^1K","^1L"]]],"^P",null,"^Q",["^H",[null,null]],"^D",1,"^R",false,"^C",150,"^S",["^4",[null,"^1>"]],"^E",150,"^U",2,"^V",true,"^G",["^H",["^I",["^H",[["^1K","^1L"]]]]],"^M","Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first previous non-blank line including or before\n  that starting line index.  Returns -1 if no non-blank line found."]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:features","~:end-row","~:else","~:read-cond","~:all","~:fail","~:after","~:before-beginning","~:current","~:do-nothing","~:before","~:clj","~:cljs","~:beyond-end","~:row","~:auto-resolve"]],"~:order",["^2>","^21","^2=","^27","^22","^26","^2:","^25","^24","^20","^23","^2?","^2;","^2<","^28","^29"]],"^M",null]